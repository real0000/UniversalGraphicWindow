/*
 * graphics_config.cpp - Platform-independent graphics configuration save/load
 */

#include "window.hpp"
#include <cstdio>
#include <cstring>
#include <cstdlib>

namespace window {

//=============================================================================
// Helper functions for parsing
//=============================================================================

static void trim_whitespace(char* str) {
    if (!str) return;

    // Trim leading
    char* start = str;
    while (*start && (*start == ' ' || *start == '\t' || *start == '\r' || *start == '\n')) {
        start++;
    }

    // Trim trailing
    char* end = start + strlen(start) - 1;
    while (end > start && (*end == ' ' || *end == '\t' || *end == '\r' || *end == '\n')) {
        *end = '\0';
        end--;
    }

    // Move trimmed string to beginning
    if (start != str) {
        memmove(str, start, strlen(start) + 1);
    }
}

static bool parse_int(const char* value, int* out) {
    if (!value || !out) return false;
    char* end;
    long val = strtol(value, &end, 10);
    if (end == value || *end != '\0') return false;
    *out = static_cast<int>(val);
    return true;
}

static bool parse_bool(const char* value, bool* out) {
    if (!value || !out) return false;
    if (strcmp(value, "true") == 0 || strcmp(value, "1") == 0 || strcmp(value, "yes") == 0) {
        *out = true;
        return true;
    }
    if (strcmp(value, "false") == 0 || strcmp(value, "0") == 0 || strcmp(value, "no") == 0) {
        *out = false;
        return true;
    }
    return false;
}

static bool parse_backend(const char* value, Backend* out) {
    if (!value || !out) return false;
    if (strcmp(value, "auto") == 0 || strcmp(value, "Auto") == 0) {
        *out = Backend::Auto;
        return true;
    }
    if (strcmp(value, "opengl") == 0 || strcmp(value, "OpenGL") == 0) {
        *out = Backend::OpenGL;
        return true;
    }
    if (strcmp(value, "vulkan") == 0 || strcmp(value, "Vulkan") == 0) {
        *out = Backend::Vulkan;
        return true;
    }
    if (strcmp(value, "d3d11") == 0 || strcmp(value, "D3D11") == 0) {
        *out = Backend::D3D11;
        return true;
    }
    if (strcmp(value, "d3d12") == 0 || strcmp(value, "D3D12") == 0) {
        *out = Backend::D3D12;
        return true;
    }
    if (strcmp(value, "metal") == 0 || strcmp(value, "Metal") == 0) {
        *out = Backend::Metal;
        return true;
    }
    return false;
}

static const char* backend_to_config_string(Backend backend) {
    switch (backend) {
        case Backend::Auto: return "auto";
        case Backend::OpenGL: return "opengl";
        case Backend::Vulkan: return "vulkan";
        case Backend::D3D11: return "d3d11";
        case Backend::D3D12: return "d3d12";
        case Backend::Metal: return "metal";
        default: return "auto";
    }
}

//=============================================================================
// GraphicsConfig Implementation
//=============================================================================

bool GraphicsConfig::save(const char* filepath) const {
    FILE* file = fopen(filepath, "w");
    if (!file) return false;

    fprintf(file, "# Graphics Configuration File\n");
    fprintf(file, "# Generated by window library\n\n");

    fprintf(file, "[window]\n");
    fprintf(file, "title = %s\n", title);
    fprintf(file, "x = %d\n", window_x);
    fprintf(file, "y = %d\n", window_y);
    fprintf(file, "width = %d\n", window_width);
    fprintf(file, "height = %d\n", window_height);

    char style_str[512];
    window_style_to_string(style, style_str, sizeof(style_str));
    fprintf(file, "style = %s\n", style_str);
    fprintf(file, "\n");

    fprintf(file, "[display]\n");
    fprintf(file, "monitor_index = %d\n", monitor_index);
    fprintf(file, "fullscreen = %s\n", fullscreen ? "true" : "false");
    fprintf(file, "fullscreen_width = %d\n", fullscreen_width);
    fprintf(file, "fullscreen_height = %d\n", fullscreen_height);
    fprintf(file, "refresh_rate = %d\n", refresh_rate);
    fprintf(file, "\n");

    fprintf(file, "[graphics]\n");
    fprintf(file, "backend = %s\n", backend_to_config_string(backend));
    fprintf(file, "device_index = %d\n", device_index);
    fprintf(file, "device_name = %s\n", device_name);
    fprintf(file, "\n");

    fprintf(file, "[rendering]\n");
    fprintf(file, "vsync = %s\n", vsync ? "true" : "false");
    fprintf(file, "samples = %d\n", samples);
    fprintf(file, "back_buffers = %d\n", back_buffers);
    fprintf(file, "color_bits = %d\n", color_bits);
    fprintf(file, "depth_bits = %d\n", depth_bits);
    fprintf(file, "stencil_bits = %d\n", stencil_bits);

    fclose(file);
    return true;
}

bool GraphicsConfig::load(const char* filepath, GraphicsConfig* out_config) {
    if (!out_config) return false;

    FILE* file = fopen(filepath, "r");
    if (!file) return false;

    // Initialize with defaults
    *out_config = GraphicsConfig{};

    char line[1024];
    char section[64] = "";

    while (fgets(line, sizeof(line), file)) {
        trim_whitespace(line);

        // Skip empty lines and comments
        if (line[0] == '\0' || line[0] == '#' || line[0] == ';') {
            continue;
        }

        // Section header
        if (line[0] == '[') {
            char* end = strchr(line, ']');
            if (end) {
                *end = '\0';
                strncpy(section, line + 1, sizeof(section) - 1);
                section[sizeof(section) - 1] = '\0';
            }
            continue;
        }

        // Key = Value
        char* eq = strchr(line, '=');
        if (!eq) continue;

        *eq = '\0';
        char* key = line;
        char* value = eq + 1;
        trim_whitespace(key);
        trim_whitespace(value);

        if (strcmp(section, "window") == 0) {
            if (strcmp(key, "title") == 0) {
                strncpy(out_config->title, value, MAX_DEVICE_NAME_LENGTH - 1);
            } else if (strcmp(key, "x") == 0) {
                parse_int(value, &out_config->window_x);
            } else if (strcmp(key, "y") == 0) {
                parse_int(value, &out_config->window_y);
            } else if (strcmp(key, "width") == 0) {
                parse_int(value, &out_config->window_width);
            } else if (strcmp(key, "height") == 0) {
                parse_int(value, &out_config->window_height);
            } else if (strcmp(key, "style") == 0) {
                parse_window_style(value, &out_config->style);
            }
        } else if (strcmp(section, "display") == 0) {
            if (strcmp(key, "monitor_index") == 0) {
                parse_int(value, &out_config->monitor_index);
            } else if (strcmp(key, "fullscreen") == 0) {
                parse_bool(value, &out_config->fullscreen);
            } else if (strcmp(key, "fullscreen_width") == 0) {
                parse_int(value, &out_config->fullscreen_width);
            } else if (strcmp(key, "fullscreen_height") == 0) {
                parse_int(value, &out_config->fullscreen_height);
            } else if (strcmp(key, "refresh_rate") == 0) {
                parse_int(value, &out_config->refresh_rate);
            }
        } else if (strcmp(section, "graphics") == 0) {
            if (strcmp(key, "backend") == 0) {
                parse_backend(value, &out_config->backend);
            } else if (strcmp(key, "device_index") == 0) {
                parse_int(value, &out_config->device_index);
            } else if (strcmp(key, "device_name") == 0) {
                strncpy(out_config->device_name, value, MAX_DEVICE_NAME_LENGTH - 1);
            }
        } else if (strcmp(section, "rendering") == 0) {
            if (strcmp(key, "vsync") == 0) {
                parse_bool(value, &out_config->vsync);
            } else if (strcmp(key, "samples") == 0) {
                parse_int(value, &out_config->samples);
            } else if (strcmp(key, "back_buffers") == 0) {
                parse_int(value, &out_config->back_buffers);
            } else if (strcmp(key, "color_bits") == 0) {
                parse_int(value, &out_config->color_bits);
            } else if (strcmp(key, "depth_bits") == 0) {
                parse_int(value, &out_config->depth_bits);
            } else if (strcmp(key, "stencil_bits") == 0) {
                parse_int(value, &out_config->stencil_bits);
            }
        }
    }

    fclose(file);

    // Validate after loading
    out_config->validate();

    return true;
}

bool GraphicsConfig::validate() {
    bool all_valid = true;

    // Validate window size
    if (window_width < 1) {
        window_width = 800;
        all_valid = false;
    }
    if (window_height < 1) {
        window_height = 600;
        all_valid = false;
    }

    // Validate samples (must be power of 2, max 16)
    if (samples < 1 || samples > 16 || (samples & (samples - 1)) != 0) {
        samples = 1;
        all_valid = false;
    }

    // Validate back buffers
    if (back_buffers < 1 || back_buffers > 4) {
        back_buffers = 2;
        all_valid = false;
    }

    // Validate color bits
    if (color_bits != 16 && color_bits != 24 && color_bits != 32) {
        color_bits = 32;
        all_valid = false;
    }

    // Validate depth bits
    if (depth_bits != 0 && depth_bits != 16 && depth_bits != 24 && depth_bits != 32) {
        depth_bits = 24;
        all_valid = false;
    }

    // Validate stencil bits
    if (stencil_bits != 0 && stencil_bits != 8) {
        stencil_bits = 8;
        all_valid = false;
    }

    // Validate backend
    if (!is_backend_supported(backend)) {
        backend = Backend::Auto;
        all_valid = false;
    }

    // Validate device exists (if specified)
    if (device_index >= 0 && device_name[0] != '\0') {
        DeviceEnumeration devices;
        enumerate_devices(backend, &devices);

        bool found = false;
        for (int i = 0; i < devices.device_count; i++) {
            if (strcmp(devices.devices[i].name, device_name) == 0) {
                // Update device_index in case it changed
                device_index = devices.devices[i].device_index;
                found = true;
                break;
            }
        }

        if (!found) {
            // Device not found, reset to default
            device_index = -1;
            device_name[0] = '\0';
            all_valid = false;
        }
    }

    // Validate monitor exists
    if (monitor_index >= 0) {
        MonitorEnumeration monitors;
        enumerate_monitors(&monitors);

        if (monitor_index >= monitors.monitor_count) {
            monitor_index = 0;  // Fall back to primary
            all_valid = false;
        }
    }

    // Validate fullscreen resolution
    if (fullscreen && fullscreen_width > 0 && fullscreen_height > 0) {
        MonitorEnumeration monitors;
        enumerate_monitors(&monitors);

        int mon_idx = (monitor_index >= 0 && monitor_index < monitors.monitor_count) ?
                      monitor_index : 0;

        if (mon_idx < monitors.monitor_count) {
            DisplayMode mode;
            if (!find_display_mode(monitors.monitors[mon_idx],
                                   fullscreen_width, fullscreen_height, refresh_rate, &mode)) {
                // Resolution not supported, use desktop resolution
                fullscreen_width = 0;
                fullscreen_height = 0;
                refresh_rate = 0;
                all_valid = false;
            }
        }
    }

    return all_valid;
}

Config GraphicsConfig::to_config() const {
    Config config;

    config.title = title;
    config.width = fullscreen && fullscreen_width > 0 ? fullscreen_width : window_width;
    config.height = fullscreen && fullscreen_height > 0 ? fullscreen_height : window_height;
    config.x = window_x;
    config.y = window_y;

    // Set style, adding fullscreen if needed
    config.style = style;
    if (fullscreen) {
        config.style |= WindowStyle::Fullscreen;
    }

    config.resizable = has_style(style, WindowStyle::Resizable);
    config.visible = true;
    config.vsync = vsync;
    config.samples = samples;
    config.backend = backend;

    // Color bits to RGB
    if (color_bits == 32) {
        config.red_bits = 8;
        config.green_bits = 8;
        config.blue_bits = 8;
        config.alpha_bits = 8;
    } else if (color_bits == 24) {
        config.red_bits = 8;
        config.green_bits = 8;
        config.blue_bits = 8;
        config.alpha_bits = 0;
    } else {
        config.red_bits = 5;
        config.green_bits = 6;
        config.blue_bits = 5;
        config.alpha_bits = 0;
    }

    config.depth_bits = depth_bits;
    config.stencil_bits = stencil_bits;
    config.back_buffers = back_buffers;
    config.shared_graphics = nullptr;

    return config;
}

//=============================================================================
// Helper functions
//=============================================================================

bool find_display_mode(const MonitorInfo& monitor, int width, int height, int refresh_rate, DisplayMode* out_mode) {
    if (!out_mode) return false;

    // First try to find exact match
    for (int i = 0; i < monitor.mode_count; i++) {
        const DisplayMode& mode = monitor.modes[i];
        if (mode.width == width && mode.height == height) {
            if (refresh_rate == 0 || mode.refresh_rate == refresh_rate) {
                *out_mode = mode;
                return true;
            }
        }
    }

    // If refresh rate was specified but not found, try any refresh rate
    if (refresh_rate != 0) {
        for (int i = 0; i < monitor.mode_count; i++) {
            const DisplayMode& mode = monitor.modes[i];
            if (mode.width == width && mode.height == height) {
                *out_mode = mode;
                return true;
            }
        }
    }

    return false;
}

bool get_primary_monitor(MonitorInfo* out_monitor) {
    if (!out_monitor) return false;

    MonitorEnumeration monitors;
    enumerate_monitors(&monitors);

    for (int i = 0; i < monitors.monitor_count; i++) {
        if (monitors.monitors[i].is_primary) {
            *out_monitor = monitors.monitors[i];
            return true;
        }
    }

    // Fall back to first monitor
    if (monitors.monitor_count > 0) {
        *out_monitor = monitors.monitors[0];
        return true;
    }

    return false;
}

} // namespace window
